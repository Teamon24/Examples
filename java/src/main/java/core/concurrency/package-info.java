/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Java Memory Model.</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Описывает то, как потоки должны взаимодейстовать через общую память.
 *
 * <p><ul>
 *  <li>Основные проблемы:
 *  <ul>
 *      <li>кэширование значнией в многопроцессорных средах</li>
 *      <li>изменение порядка операций для оптимизации.</li>
 *  </ul></ul>
 * <ul>
 * <li>Инструменты для решения:
 *      <ul>
 *      <li>final - не изменять переменную</li>
 *      <li>volatile - не кэшировать, всегда считывать из общей памяти (даже в случае многоядерности)</li>
 *      <li>synchronized - отметить участок кода доступный одному потоку.</li>
 *      </ul>
 * </li>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Процессы и потоки:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p> - процесс (с точки зрения ОС) - это отдельная программа, с выделенной виртуальной памятью.
 * <p> - у процессов нет общей памяти, когда у потоков - есть.
 * <p> - поток - часть приложения, который разделяет память приложения с другими потоками.
 * <p> - потоки в Java связаны с потоками операционной системы, которые являются ресурсом системы,
 * поэтому неаккуратное создание java-потоков может привести к неэкономному использованию ресурсов ОС.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Состояния потока:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>- получение состояния: <i>Thread#getState()</i>
 * <p>- NEW: поток, который был создан, но не был запущен при помощи <i>thread#start()</i>.
 * <p>- RUNNABLE: поток, который в любой момент можно приостановить или возобновить.
 * <p>- BLOCKED: поток, который зашел в <i>synchronized</i> секцию, но не может продолжить
 * выполнение инструкций, т.к. другой поток использует монитор данной секции.
 * <p>- WAITING: поток переходит в это состояние при вызове <i>object#wait()</i>, и ждет, что другой поток совершит определенное действие.
 * <p>- TIMED_WAITING: поток в том же состояние, что и выше, но переведенный в это состояние методами <i>thread#sleep(long)</i>, <i>object#wait(long)</i>, <i>thread#join(long)</i>.
 * <p>- TERMINATED: поток завершил задачу и был удален.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Runnable и Callable:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p> - интерфейс <i>Runnable</i> имеет один метод <i>run</i>, где содержится логика потока, которая не подразумевает возвращение результата.
 * <p> - интерфейс <i>Callable</i> имеет также один метод <i>call</i>, который возвращает результат и может выбрасывать исключение. Данный интерфейс, в основном, используется в <i>ExecutorService</i>, чтобы запустить параллельное выполнение и вернуть <i>Future</i> для получения результат.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Демон-потоки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>- потоки, которые на завершают свою работу при закрытии JVM.
 * <p>- испльзуются для выполенения сервисной задачи.
 * <p>- могут быть проигнорированы в любой момент
 * <p>- создание демон-потока: <i>thread#setDeamon(Boolean)</i>
 * <p>- finally блок не будет выполнен, если работа демон-потока будет проигнорирована, поэтому работа с потоками данных не должна проводиться в демон-потоках.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Флаг прерывания</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>или статус прерывания, это внутренний флаг потока, который устанавлевается когда поток прерван
 * методом thread#interrupt().
 * <p>Если поток находится внтури методов <i>wait</i>, <i>join</i>, <i>sleep</i> и т.д., тогда выбросится исключение InterruptedException, котороое поток может обрабовать необходимым способом.
 * <p>Если поток не находится в выше указанных методов, тогда поток прервется без выброса исключений. Каким образом проверять статус прерывания поток определяет он сам, и производить проверку можно
 * при помощи <i>thread#isInterrupted()</i> или <i>Thread#interrupted</i>. Разница между методами объекта и статическим методом - в сбросе флага прерывания. Статический метод сбрасывает флаг, а метоод объекта - только проверяет.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Executor и ExecutorService</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * -
 */
package core.concurrency;