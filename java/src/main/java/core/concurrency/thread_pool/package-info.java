/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://www.baeldung.com/thread-pool-java-and-guava#Thread">
 * <strong>Thread Pool в Java</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Потоки в Java связаны с потоками операционной системы, которые являются ресурсом системы,
 * поэтому неаккуратное создание java-потоков может привести к неэкономному использованию ресурсов ОС.
 * <p>Операционая система может также переназначать задачи между потоками для реализации параллелизма.
 * Говоря проще,чем больше потоков, тем меньше времени каждый из них тратит на выполнение задач.
 * <p><i>Thread Pool</i> паттерн экономить ресурсы в многопоточном приложении опредленным образом.
 * <p>Когда мы используем <i>Thread Pool</i>, мы пишем код, который должен выполняться параллельно,
 * в форме параллельных задач, которые передаем на выполнение объекту <i>Thread Pool</i>.
 * Этот объект распределяет задачи между несколькими переиспользуемыми потоками (<i>Thread</i>).
 * <p>Паттерн позволяет задать количество переиспользуемых потоков и контролировать их жизненный цикл.</p>
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://www.baeldung.com/thread-pool-java-and-guava#1-executors-executor-and-executorservice">
 * <strong>Executors, Executor и ExecutorService</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Класс <i>Executors</i> содержит несколько методов создания настроенных определенным образом <i>Thread Pool</i>.
 * <p>Их можно использовать по умолчанию, когда нет необходимости в ручной настройке.
 * <p>Использование интерфесов <i>Executor</i> и <i>ExecutorService</i> дает возможность работать с различными
 * реализациями паттерна <i>Thread Pool</i>. Обычно, код не должен зависеть от конкретной реализации паттерна и должен
 * использовать интерфейсы.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Executor</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Интерфейс имеет единственный метод executor#execute(Runnable):
 * <pre>
 * {@code
 * Executor executor = Executors.newSingleThreadExecutor();
 * executor.execute(() -> System.out.println("Hello World"));}
 * </pre>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>ExecutorService</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Интерфейс содержит большое количество методов по контролю выполнения задач и остановке собвственного сервиса.
 * Возможно подвердить готовность выполнить задачу
 * (метод executorService#submit()), а также контролировать ее выполнение, используя интерфейс Future.
 * Future может возвращать результат выполнения задачи (метод future#get()):
 * <pre>
 * {@code
 * ExecutorService executorService = Executors.newFixedThreadPool(10);
 * Future<?> runnableFuture = executorService.submit(() -> System.out.println("Hello World"));
 * Future<String> callableFuture = executorService.submit(() -> "Hello World");;
 * String runnableResult = runnableFuture.get();
 * String callableResult = callableFuture.get();}
 * </pre>
 * <p>Обычно, при разработке, результат выполнения задачи запрашивается в момент, когда этот результат необходим, т.е. немного позже, чем момент подтверждения задачи.</p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://www.baeldung.com/thread-pool-java-and-guava#2-threadpoolexecutor"><strong>ThreadPoolExecutor</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>- это расширенная реализация паттерна Thread Pool со множеством параметров для настройки:
 * <pre>
 * {@code
 * ThreadPoolExecutor(int corePoolSize,
 *                    int maximumPoolSize,
 *                    long keepAliveTime,
 *                    TimeUnit unit,
 *                    BlockingQueue<Runnable> workQueue}
 * </pre>
 * <p>Thread pool состоит из фиксированного числа основных потоков.
 * Также в пуле есть дополнительные потоки, которые могут быть вызваны и после закрыты,
 * когда они уже не нужны.
 * <p>Параметр <i>corePoolSize</i> задает количество основных потоков. Когда подтвержается новая задача,
 * а все основные потоки заняты и очередь задач заполнена, thread pool создает дополнительные потоки до значения
 * параметра maximumPoolSize.
 * <p>Параметр <i>keepAliveTime</i> задает интервал времени, по истечениии которого потоки, выделенные дополнительно,
 * перестают использоваться. По умолчанию, ThreadPoolExecutor перестает использовать только дополнительные потоки.
 * Для того чтобы и основные потоки можно было исключить из использования вызывается метод
 * <i>threadPoolExecutor#allowCoreThreadTimeOut(Boolean)</i>.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>newFixedThreadPool</strong>, <strong>newCachedThreadPool</strong>, <strong>newSingleThreadExecutor</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>newFixedThreadPool(corePoolSize)</li>
 * Создается thread pool, где corePoolSize - фиксированно, maximumPoolSize равно corePoolSize,  keepAliveTime - 0 секунд.
 * <li>newCachedThreadPool()</li>
 * Создается thread pool, где corePoolSize - 0, maximumPoolSize - Integer.MAX_VALUE. keepAliveTime - 60 секунд.
 * <li>newSingleThreadExecutor()</li>
 * Создается thread pool, где corePoolSize - 1, maximumPoolSize - 1. keepAliveTime - 0 секунд.
 * <li>newScheduledThreadPool(corePoolSize)</li>
 * Создается thread pool, где corePoolSize - фиксировано, maximumPoolSize - Integer.MAX_VALUE. keepAliveTime - 0 секунд.
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://www.baeldung.com/thread-pool-java-and-guava#3-scheduledthreadpoolexecutor">
 *     <strong>ScheduledThreadPoolExecutor</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>расширяет ThreadPoolExecutor и реализует ScheduledExecutorService.
 * <p><ul>
 * <li>ScheduledExecutorService:
 * <ul>
 *  <li><i>schedule(Runnable command, long delay, TimeUnit unit)</i></li>
 *      запускает задачу после окончания определенного промежутка времени.
 *  <li><i>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</i></li>
 *      запускает задачу с определенным периодом после определенного момента времени.
 *  <li><i>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</i></li>
 *      запускает задачу с определенным периодом и задержкой, которая определяется с момента окончания запуска
 *      предущего повторения задачи до момента начала запуска следующего. Скорость выполнения может изменяться
 *      в зависимости от времени, которое требуется любому запуску задачи
 *  </ul></li></ul>
 *
 * ---------------------------------------------------------------------------------------------------------------------
 *  <p><a href="https://www.baeldung.com/thread-pool-java-and-guava#2-direct-executor-and-direct-executor-service">
 *     <strong>Direct Executor and Direct Executor Service (Guava)</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Иногда необходимо запустить задачу в текущем потоке, что DirectExecutor/DirectExecutorService
 * и делает. Задача запущенная при помощи них блокирует текущий поток.</p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://www.baeldung.com/thread-pool-java-and-guava#3-exiting-executor-services">
 *     <strong>Exiting Executor Services</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Частая проблема - остановка виртуальной машины, в то время как thread pool еще выполняет задачи.
 * <p>Даже с предосталенными механизмами отмены выполнения задач, нет гарантий того, что задача
 * будет остановлена при остановке executor service. Это может задержать остановку виртуальной машины.
 * <p>Чтобы решить данную проблему, <strong>Guava</strong> предлагает несколько executor service. Они базируются
 * на демон-потоках, которые останавливаются вместе с JVM.
 *
 * Сервисы предлагают shutdown hook с методом {@code Runtime.getRuntime().addShutdownHook()}
 * и откладывает остановку виртуальной машины на заданное время перед тем, как остановить "зависшие" задачи.
 *
 *
 */
package core.concurrency.thread_pool;