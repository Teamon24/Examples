/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/bridge"><strong>Мост</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>это структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных
 * иерархий, которые потом можно развивать отдельно друг от друга. Одна из этих иерархий (абстракция)
 * получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу.
 * Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Абстракция и Реализация</strong> (см. UML-диаграмму)</p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Эти термины были введены в книге GoF  при описании Моста. На мой взгляд, они выглядят слишком академичными,
 * делая описание паттерна сложнее, чем он есть на самом деле. Помня о примере с фигурами и цветами,
 * давайте все же разберёмся, что имели в виду авторы паттерна.
 *
 * <p>Итак, абстракция (или интерфейс) — это образный слой управления чем-либо. Он не делает работу самостоятельно,
 * а делегирует её слою реализации (иногда называемому платформой).
 *
 * <ul>Только не путайте эти термины с интерфейсами или абстрактными классами из вашего языка программирования,
 * это не одно и то же.</ul>
 *
 * <p>Если говорить о реальных программах, то абстракцией может выступать графический интерфейс программы (GUI),
 * а реализацией — низкоуровневый код операционной системы (API), к которому графический интерфейс обращается
 * по реакции на действия пользователя.
 *
 * <p>Вы можете развивать программу в двух разных направлениях:
 * <ul>
 * <li>иметь несколько видов GUI (например, для простых пользователей и администраторов);</li>
 * <li>поддерживать много видов API (например, работать под Windows, Linux и macOS).</li>
 * </ul>
 * <p>Такая программа может выглядеть как один большой клубок кода, в котором намешаны условные операторы слоёв GUI и API.
 *
 * <p>Вы можете попытаться структурировать этот хаос, создав для каждой вариации интерфейса-платформы свои подклассы.
 * Но такой подход приведёт к росту классов комбинаций, и с каждой новой платформой их будет всё больше.
 *
 * <p>Мы можем решить эту проблему, применив Мост. Паттерн предлагает распутать этот код, разделив его на две части:
 * <ul>
 * <li>Абстракцию: слой графического интерфейса приложения.</li>
 * <li>Реализацию: слой взаимодействия с операционной системой.</li>
 * </ul>
 *
 * <p>Абстракция будет делегировать работу одному из объектов реализаций. Причём, реализации можно будет взаимозаменять,
 * но только при условии, что все они будут следовать общему интерфейсу.
 *
 * <p>Таким образом, вы сможете изменять графический интерфейс приложения, не трогая низкоуровневый код работы с
 * операционной системой. И наоборот, вы сможете добавлять поддержку новых операционных систем,
 * создавая подклассы реализации, без необходимости менять классы графического интерфейса.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Области применения:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>паттерн Мост особенно полезен когда вам приходится делать кросс-платформенные приложения,
 * поддерживать несколько типов баз данных или работать с разными поставщиками
 * похожего API (например, cloud-сервисы, социальные сети и т. д.)
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности
 * (например, если класс может работать с разными системами баз данных):
 * <p>- чем больше класс, тем тяжелее разобраться в его коде, и тем больше это затягивает разработку. Кроме того,
 * изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести
 * к внесению случайных ошибок в код.
 * <p>- мост позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код
 * независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.
 * <p>2. Когда класс нужно расширять в двух независимых плоскостях:<p>
 * <p>- мост предлагает выделить одну из таких плоскостей в отдельную иерархию классов, храня ссылку на один из её
 * объектов в первоначальном классе.
 * <p>* Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы:
 * <p>- мост позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита»
 * в класс абстракции: кстати, из-за этого пункта Мост часто путают со Стратегией. Обратите внимание, что у Моста этот
 * пункт стоит на последнем месте по
 * значимости, поскольку его главная задача — структурная.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть
 * функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация.
 * <p>2. Продумайте, какие операции будут нужны клиентам, и опишите их в базовом классе абстракции.
 * <p>3. Определите поведения, доступные на всех платформах, и выделите из них ту часть, которая нужна абстракции.
 * На основании этого опишите общий интерфейс реализации.
 * <p>4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу,
 * который мы выделили перед этим.
 * <p>5. Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную
 * работу связанному объекту реализации.
 * <p>6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
 * <p>7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он
 * может свободно использовать объект абстракции, забыв о реализации.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>+: позволяет строить платформо-независимые программы.
 * <p>+: скрывает лишние или опасные детали реализации от клиентского кода.
 * <p>+: реализует принцип открытости/закрытости.
 * <p>-: усложняет код программы из-за введения дополнительных классов.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <li> <strong><i>Мост</i></strong> проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. <strong><i>Адаптер</i></strong> применяется
 * постфактум, чтобы заставить несовместимые классы работать вместе.</li>
 * <li> <strong><i>Мост</i></strong>, <strong><i>Стратегия</i></strong> и <strong><i>Состояние</i></strong> (а также слегка и <strong><i>Адаптер</i></strong>) имеют схожие структуры классов — все они построены на
 * принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают
 * разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание
 * проблем, которые привели к данному решению.</li>
 * <li> <strong><i>Aбстрактная фабрика</i></strong> может работать совместно с <strong><i>Мостом</i></strong>. Это особенно полезно, если у вас есть абстракции,
 * которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять
 * типы создаваемых абстракций и реализаций.</li>
 * <li> паттерн <strong><i>Строитель</i></strong> может быть построен в виде <strong><i>Моста</i></strong>: директор будет играть роль абстракции,
 * а строители — реализации.</li>
 */
package patterns.basic.refactoring.guru.structural.bridge;