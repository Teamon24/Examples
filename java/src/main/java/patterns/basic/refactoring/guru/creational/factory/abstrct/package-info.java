/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/abstact-factory"><strong>Абстрактная фабрика</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.
 *
 * <ul>Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.</ul>
 *
 * <p>* Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.
 *
 * <ul>В хорошей программе каждый класс отвечает только за одну вещь. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
 *
 * <p>2. Сведите все вариации продуктов к общим интерфейсам.
 *
 * <p>3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
 *
 * <p>4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
 *
 * <p>5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
 *
 * <p>6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": гарантирует сочетаемость создаваемых продуктов.
 * <p>"+": избавляет клиентский код от привязки к конкретным классам продуктов.
 * <p>"+": выделяет код производства продуктов в одно место, упрощая поддержку кода.
 * <p>"+": упрощает добавление новых продуктов в программу.
 * <p>"+": реализует принцип открытости/закрытости.
 * <p>"-": усложняет код программы из-за введения множества дополнительных классов.
 * <p>"-": требует наличия всех типов продуктов в каждой вариации.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>Многие архитектуры начинаются с применения Фабричного метода (более простого и расширяемого через подклассы) и эволюционируют в сторону Абстрактной фабрики, Прототипа или Строителя (более гибких, но и более сложных).</li>
 *
 * <li>Строитель концентрируется на построении сложных объектов шаг за шагом. Абстрактная фабрика специализируется на создании семейств связанных продуктов. Строитель возвращает продукт только после выполнения всех шагов, а Абстрактная фабрика возвращает продукт сразу же.</li>
 *
 * <li>Классы Абстрактной фабрики чаще всего реализуются с помощью Фабричного метода, хотя они могут быть построены и на основе Прототипа.</li>
 *
 * <li>Абстрактная фабрика может быть использована вместо Фасада для того, чтобы скрыть платформо-зависимые классы.</li>
 *
 * <li>Абстрактная фабрика может работать совместно с Мостом. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.</li>
 *
 * <li>Абстрактная фабрика, Строитель и Прототип могут быть реализованы при помощи Одиночки.</li>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Абстрактной фабрики в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>javax.xml.parsers.DocumentBuilderFactory#newInstance()</li>
 * <li>javax.xml.transform.TransformerFactory#newInstance()</li>
 * <li>javax.xml.xpath.XPathFactory#newInstance()</li>
 * </ul>
 */
package patterns.basic.refactoring.guru.creational.factory.abstrct;