/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/builder"><strong>Строитель</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
 * Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда вы хотите избавиться от «телескопического конструктора».
 *
 * <ul>Допустим, у вас есть один конструктор с десятью опциональными параметрами. Его неудобно вызывать,
 * поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. Всё, что они делают —
 * это переадресуют вызов к базовому конструктору, подавая какие-то значения по умолчанию в параметры,
 * которые пропущены в них самих.
 *     <pre>{@code class Pizza {
 *     Pizza(int size) { ... }
 *     Pizza(int size, boolean cheese) { ... }
 *     Pizza(int size, boolean cheese, boolean pepperoni) { ... }}
 *     //Такого монстра можно создать только в языках, имеющих механизм перегрузки методов, например, C# или Java.
 *     }</pre>
 *
 * <ul>Паттерн Строитель позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны.
 * А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.
 * </ul>
 * <p>* Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома.
 * <ul> Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов,
 * которые отличаются в деталях.</ul>
 * <ul> Интерфейс строителей определит все возможные этапы конструирования. Каждому представлению будет
 * соответствовать собственный класс-строитель. А порядок этапов строительства будет задавать класс-директор.</ul>
 * <p>* Когда вам нужно собирать сложные составные объекты, например, деревья Компоновщика.
 * <ul> Строитель конструирует объекты пошагово, а не за один проход. Более того, шаги строительства можно выполнять
 * рекурсивно. А без этого не построить древовидную структуру, вроде Компоновщика.</ul>
 * <ul> Заметьте, что Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту,
 * пока тот не будет полностью готов. Это предохраняет клиентский код от получения незаконченных «битых» объектов.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам.
 * <p>2. Опишите эти шаги в общем интерфейсе строителей.
 * <p>3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.
 * <ul>Не забудьте про метод получения результата. Обычно конкретные строители определяют собственные методы получения результата строительства. Вы не можете описать эти методы в интерфейсе строителей, поскольку продукты не обязательно должны иметь общий базовый класс или интерфейс. Но вы всегда сможете добавить метод получения результата в общий интерфейс, если ваши строители производят однородные продукты с общим предком.</ul>
 * <p>4. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.
 * <p>5. Клиентский код должен будет создавать и объекты строителей, и объект директора. Перед началом строительства клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в строительный метод директора.
 * <p>6. Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе вы жёстко привяжете директора к конкретным классам строителей.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": Позволяет создавать продукты пошагово.
 * <p>"+": Позволяет использовать один и тот же код для создания различных продуктов.
 * <p>"+": Изолирует сложный код сборки продукта от его основной бизнес-логики.
 * <p>"-": Усложняет код программы из-за введения дополнительных классов.
 * <p>"-": Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения результата.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>Многие архитектуры начинаются с применения Фабричного метода (более простого и расширяемого через подклассы)
 * и эволюционируют в сторону Абстрактной фабрики, Прототипа или Строителя (более гибких, но и более сложных).</li>
 * <li>Строитель концентрируется на построении сложных объектов шаг за шагом. Абстрактная фабрика специализируется
 * на создании семейств связанных продуктов. Строитель возвращает продукт только после выполнения всех шагов,
 * а Абстрактная фабрика возвращает продукт сразу же.</li>
 * <li>Строитель позволяет пошагово сооружать дерево Компоновщика.</li>
 * <li>Паттерн Строитель может быть построен в виде Моста: директор будет играть роль абстракции,
 * а строители — реализации.</li>
 * <li>Абстрактная фабрика, Строитель и Прототип могут быть реализованы при помощи Одиночки.</li>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры паттерна Строитель в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>java.lang.StringBuilder#append() (unsynchronized)</li>
 * <li>java.lang.StringBuffer#append() (synchronized)</li>
 * <li>java.nio.ByteBuffer#put() (также в CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer и DoubleBuffer)</li>
 * <li>javax.swing.GroupLayout.Group#addComponent()</li>
 * <li>Все реализации java.lang.Appendable</li>
 * </ul>
 */
package patterns.basic.refactoring.guru.creational.builder;