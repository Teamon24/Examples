/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/prototype"><strong>Адаптер</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>— это структурный паттерн, который позволяет подружить несовместимые объекты.
 * Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Цели:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>конвертация разных типов данных или
 * совместная работа классов с разными интерфейсами.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения —
 * адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат,
 * понятный стороннему классу.
 * <p>* Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то
 * общей функциональности, причём расширить суперкласс вы не можете:
 * <ul><li> Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность.
 * Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.
 * Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить
 * его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии.
 * Это решение будет сильно напоминать паттерн Декоратор.</li></ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong> Шаги реализации:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
 * <p>- полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний,
 * либо от него зависит другой код);
 * <p>- один или несколько клиентов — существующих классов приложения, несовместимых с сервисом
 * из-за неудобного или несовпадающего интерфейса.
 * <p>2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
 * <p>3. Создайте класс адаптера, реализовав этот интерфейс.
 * <p>4. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса.
 * Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект
 * можно передавать через параметры методов адаптера.
 * <p>5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
 * <p>6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять
 * и добавлять адаптеры в будущем.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p> "+": отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
 * <p> "-": усложняет код программы из-за введения дополнительных классов.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li><strong>Мост</strong> проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга.
 * <strong>Адаптер</strong> применяется
 * постфактум, чтобы заставить несовместимые классы работать вместе.</li>
 * <li><strong>Адаптер</strong> меняет интерфейс существующего объекта. <strong>Декоратор</strong> улучшает
 * другой объект без изменения его интерфейса.
 * Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.</li>
 * <li>Адаптер предоставляет классу альтернативный интерфейс. Декоратор предоставляет расширенный интерфейс.
 * Заместитель предоставляет тот же интерфейс.</li>
 * <li><strong>Фасад</strong> задаёт новый интерфейс, тогда как <strong>Адаптер</strong> повторно использует старый.
 * Адаптер оборачивает только один
 * класс, а Фасад оборачивает целую подсистему. Кроме того, Адаптер позволяет двум существующим интерфейсам работать
 * сообща, вместо того, чтобы задать полностью новый.</li>
 * <li><strong>Мост</strong>, <strong>Стратегия</strong> и <strong>Состояние</strong>
 * (а также слегка и <strong>Адаптер</strong>) имеют схожие структуры классов — все они построены
 * на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем,
 * что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом,
 * но и описание проблем, которые привели к данному решению.</li>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Адаптеров в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>*<strong>java.util.Arrays#asList()</strong>
 * <p>*<strong>java.util.Collections#list()</strong>
 * <p>*<strong>java.util.Collections#enumeration()</strong>
 * <p>*<strong>java.io.InputStreamReader(InputStream)</strong> (возвращает объект Reader)
 * <p>*<strong>java.io.OutputStreamWriter(OutputStream)</strong> (возвращает объект Writer)
 * <p>*<strong>javax.xml.bind.annotation.adapters.XmlAdapter#marshal()</strong> и <strong>#unmarshal()</strong>
 *
 */
package patterns.refactoring.guru.structural.adapter;