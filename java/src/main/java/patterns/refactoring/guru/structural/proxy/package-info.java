/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href=https://refactoring.guru/ru/design-patterns/proxy><strong>Заместитель</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * это структурный паттерн проектирования,
 * который позволяет подставлять вместо реальных объектов специальные объекты-заменители.
 * Эти объекты перехватывают вызовы к оригинальному объекту,
 * позволяя сделать что-то до или после передачи вызова оригиналу.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Цели применения:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * Паттерн Proxy применяется в Java коде тогда,
 * когда надо заменить настоящий объект его суррогатом,
 * причём незаметно для клиентов настоящего объекта.
 * Это позволит выполнить какие-то добавочные поведения
 * до или после основного поведения настоящего объекта.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы
 * или базы данных.
 * <ul>Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда,
 * когда он действительно понадобится.</ul>
 * <p>* Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать
 * объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы,
 * а пользователи — сторонние программы (хорошие или вредоносные).
 * <ul>Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту,
 * если доступ разрешён.</ul>
 * <p>* Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.
 * <ul>В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе,
 * понятном удалённому сервису.</ul>
 * <p>* Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.
 * <ul>Заместитель может сохранять историю обращения клиента к сервисному объекту.</ul>
 * <p>* Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов
 * и управлять их жизненным циклом.
 * <ul>Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и
 * остаются активными. Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект
 * (например, закрыть подключение к базе данных).</ul>
 * <ul>Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать
 * объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
 * <p>2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект
 * создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект
 * от клиента через конструктор.
 * <p>3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то
 * полезную работу, методы заместителя должны передать запрос сервисному объекту.
 * <p>4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный
 * сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
 * <p>5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к
 * методам заместителя.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": Позволяет контролировать сервисный объект незаметно для клиента.
 * <p>"+": Может работать, даже если сервисный объект ещё не создан.
 * <p>"+": Может контролировать жизненный цикл служебного объекта.
 * <p>"-": Усложняет код программы из-за введения дополнительных классов.
 * <p>"-": Увеличивает время отклика от сервиса.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul><li><strong>Адаптер</strong> предоставляет классу альтернативный интерфейс. <strong>Декоратор</strong> предоставляет расширенный интерфейс. <strong>Заместитель</strong> предоставляет тот же интерфейс.</li></ul>
 *
 * <ul><li><strong>Фасад</strong> похож на <strong>Заместитель</strong> тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от Фасада, Заместитель имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.</li></ul>
 *
 * <ul><li><strong>Декоратор</strong> и <strong>Заместитель</strong> имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что Заместитель сам управляет жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.</li></ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Заместителя в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * - java.lang.reflect.Proxy
 * - java.rmi.*
 * - javax.ejb.EJB (см. комментарии)
 * - javax.inject.Inject (см. комментарии)
 * - javax.persistence.PersistenceContext
 */
package patterns.refactoring.guru.structural.proxy;