/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/strategy"><strong>
 * Стратегия</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
 * <ul>Стратегия позволяет варьировать поведение объекта во время выполнения программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).</ul>
 * <p>* Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
 * <ul>Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов, а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым.</ul>
 * <p>* Когда вы не хотите обнажать детали реализации алгоритмов для других классов.
 * <ul>Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов, скрыв эти детали внутри классов-стратегий.</ul>
 * <p>* Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.
 * <ul>Стратегия помещает каждую лапу такого оператора в отдельный класс-стратегию. Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.
 *
 * <p>2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
 *
 * <p>3. Поместите вариации алгоритма в собственные классы, которые реализуют этот интерфейс.
 *
 * <p>4. В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию, а также метод для её изменения. Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.
 *
 * <p>5. Клиенты контекста должны подавать в него соответствующий объект-стратегию, когда хотят, чтобы контекст вёл себя определённым образом.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": горячая замена алгоритмов на лету.
 * <p>"+": изолирует код и данные алгоритмов от остальных классов.
 * <p>"+": уход от наследования к делегированию.
 * <p>"+": реализует принцип открытости/закрытости.
 * <p>"-": усложняет программу за счёт дополнительных классов.
 * <p>"-": клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li><strong>Мост</strong>, <strong>Стратегия</strong> и <strong>Состояние</strong> (а также слегка и <strong>Адаптер</strong>) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.</li>
 *
 * <li><strong>Команда</strong> и <strong>Стратегия</strong> похожи по духу, но отличаются масштабом и применением:
 * <ul>
 * <li><i>Команду</i> используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.</li>
 * <li>С другой стороны, <i>Стратегия</i> описывает разные способы произвести одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.</li>
 * </ul>
 * </li>
 * <li><strong>Стратегия</strong> меняет поведение объекта «изнутри», а <strong>Декоратор</strong> изменяет его «снаружи».</li>
 * <li><strong>Шаблонный</strong> метод использует наследование, чтобы расширять части алгоритма. <strong>Стратегия</strong> использует делегирование, чтобы изменять выполняемые алгоритмы на лету. <i>Шаблонный метод</i> работает на уровне классов. Стратегия позволяет менять логику отдельных объектов.</li>
 *
 * <li><strong>Состояние</strong> можно рассматривать как надстройку над <strong>Стратегией</strong>. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в <i>Стратегии</i> эти объекты не знают друг о друге и никак не связаны. В <i>Состоянии</i> сами конкретные состояния могут переключать контекст.</li>
 * </ul>
 */
package patterns.refactoring.guru.behavioral.strategy;