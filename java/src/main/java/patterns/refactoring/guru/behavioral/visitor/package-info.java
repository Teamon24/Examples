/**
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/visitor"><strong>Посетитель</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 *
 * — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
 * <ul>Посетитель позволяет применять одну и ту же операцию к объектам различных классов.</ul>
 * <p>* Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.
 * <ul>Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции.</ul>
 * <p>* Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
 * <ul>Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.</ul>
 *  ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса элемента, который существует в программе.
 * <p>2. Опишите интерфейс элементов. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия посетителей в базовом классе иерархии элементов.
 * <p>3. Реализуйте методы принятия во всех конкретных элементах. Они должны переадресовывать вызовы тому методу посетителя, в котором тип параметра совпадает с текущим классом элемента.
 * <p>4. Иерархия элементов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать обо всех классах элементов.
 * <p>5. Для каждого нового поведения создайте конкретный класс посетителя. Приспособьте это поведение для работы со всеми типами элементов, реализовав все методы интерфейса посетителей.
 * <ul>Вы можете столкнуться с ситуацией, когда посетителю нужен будет доступ к приватным полям элементов. В этом случае вы можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию элементов, либо сделать класс посетителя вложенным в класс элемента, если вам повезло писать на языке, который поддерживает вложенность классов.</ul>
 * <p>6. Клиент будет создавать объекты посетителей, а затем передавать их элементам, используя метод принятия.
 *
 *  ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": упрощает добавление операций, работающих со сложными структурами объектов.
 * <p>"+": объединяет родственные операции в одном классе.
 * <p>"+": посетитель может накапливать состояние при обходе структуры элементов.
 * <p>"-": паттерн не оправдан, если иерархия элементов часто меняется.
 * <p>"-": может привести к нарушению инкапсуляции элементов.
 *  ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li><strong>Посетитель</strong> можно рассматривать как расширенный аналог <strong>Команды</strong>, который способен работать сразу с несколькими видами получателей.</li>
 * <li>Вы можете выполнить какое-то действие над всем деревом <strong>Компоновщика</strong> при помощи <strong>Посетителя</strong>.</li>
 * <li><strong>Посетитель</strong> можно использовать совместно с <strong>Итератором</strong>. <i>Итератор</i> будет отвечать за обход структуры данных, а <i>Посетитель</i> — за выполнение действий над каждым её компонентом.</li>
 * </ul>
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Посетителей в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>javax.lang.model.element.AnnotationValue</strong> и <strong>AnnotationValueVisitor</strong>
 * <p><strong>javax.lang.model.element.Element</strong> и <strong>ElementVisitor</strong>
 * <p><strong>javax.lang.model.type.TypeMirror</strong> и <strong>TypeVisitor</strong>
 * <p><strong>java.nio.file.FileVisitor</strong> и <strong>SimpleFileVisitor</strong>
 * <p><strong>javax.faces.component.visit.VisitContext</strong> и <strong>VisitCallback</strong>
 */
package patterns.refactoring.guru.behavioral.visitor;