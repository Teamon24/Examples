/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/mediator"><strong>Посредник</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.
 * <ul>Посредник позволяет поместить все эти связи в один класс, после чего вам будет легче их отрефакторить, сделать более понятными и гибкими.</ul>
 * <p>* Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.
 * <ul>После применения паттерна компоненты теряют прежние связи с другими компонентами, а всё их общение происходит косвенно, через объект-посредник.</ul>
 * <p>* Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах.
 * <ul>Если раньше изменение отношений в одном компоненте могли повлечь за собой лавину изменений во всех остальных компонентах, то теперь вам достаточно создать подкласс посредника и поменять в нём связи между компонентами.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например, чтобы повторно использовать их код в другой программе.
 * <p>2. Создайте общий интерфейс посредников и опишите в нём методы для взаимодействия с компонентами. В простейшем случае достаточно одного метода для получения оповещений от компонентов.
 * <ul>Этот интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач. В этом случае всё, что нужно сделать — это создать новый класс конкретного посредника.</ul>
 * <p>3. Реализуйте этот интерфейс в классе конкретного посредника. Поместите в него поля, которые будут содержать ссылки на все объекты компонентов.
 * <p>4. Вы можете пойти дальше и переместить код создания компонентов в класс посредника, после чего он может напоминать фабрику или фасад.
 * <p>5. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобнее всего установить, подавая посредника в параметры конструктора компонентов.
 * <p>6. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, вместо методов других компонентов. С противоположной стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение от компонента.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": устраняет зависимости между компонентами, позволяя повторно их использовать.
 * <p>"+": упрощает взаимодействие между компонентами.
 * <p>"+": централизует управление в одном месте.
 * <p>"-": посредник может сильно раздуться.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul><li>
 * <strong>Цепочка обязанностей</strong>, <strong>Команда</strong>, <strong>Посредник</strong> и <strong>Наблюдатель</strong> показывают различные способы работы отправителей запросов с их получателями:
 * <ul>
 * <li><i>Цепочка обязанностей</i> передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.</li>
 * <li><i>Команда</i> устанавливает косвенную одностороннюю связь от отправителей к получателям.</li>
 * <li><i>Посредник</i> убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.</li>
 * <li><i>Наблюдатель</i> передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.</li>
 * </ul></li><li>
 * <strong>Посредник</strong> и <strong>Фасад</strong> похожи тем, что пытаются организовать работу множества существующих классов.
 * <ul>
 * <li><i>Фасад</i> создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании Фасада. Классы подсистемы общаются друг с другом напрямую.</li>
 * <li><i>Посредник</i> централизует общение между компонентами системы. Компоненты системы знают только о существовании Посредника, у них нет прямого доступа к другим компонентам.</li></ul></li>
 * <li>Разница между <strong>Посредником</strong> и <strong>Наблюдателем</strong> не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.</li>
 * <ul>Цель <i>Посредника</i> — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель <i>Наблюдателя</i> — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.</ul>
 * <ul>Довольно популярна реализация <i>Посредника</i> при помощи <i>Наблюдателя</i>. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.</ul>
 * <ul>Но <i>Посредник</i> имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать <i>Наблюдателя</i>, но всё же останется <i>Посредником</i>.</ul>
 * <ul>Напротив, в случае реализации посредника с помощью <i>Наблюдателя</i> представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети <i>Наблюдателей</i>, не имея центрального объекта-<i>Посредника</i>.</ul>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Посредника в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>java.util.Timer</strong> (все методы scheduleXXX())
 * <p><strong>java.util.concurrent.Executor#execute()</strong>
 * <p><strong>java.util.concurrent.ExecutorService</strong> (методы invokeXXX() и submit())
 * <p><strong>java.util.concurrent.ScheduledExecutorService</strong> (все методы scheduleXXX())
 * <p><strong>java.lang.reflect.Method#invoke()</strong>
 */
package patterns.refactoring.guru.behavioral.mediator;