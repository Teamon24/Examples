/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/template-method"><strong>
 * Шаблонный метод</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 *
 * — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.
 *
 * <ul>Шаблонный метод позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в базовом классе.</ul>
 *
 * <p>* Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.
 *
 * <ul>Паттерн шаблонный метод предлагает создать для похожих классов общий суперкласс и оформить в нём главный алгоритм в виде шагов. Отличающиеся шаги можно переопределить в подклассах.</ul>
 *
 * Это позволит убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Прикиньте, какие шаги будут стандартными для всех вариаций алгоритма, а какие — изменяющимися.
 * <p>2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов алгоритма. Имеет смысл сделать шаблонный метод финальным, чтобы подклассы не могли переопределить его (если ваш язык программирования это позволяет).
 * <p>3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. Вы можете сделать эти методы абстрактными или добавить какую-то реализацию по умолчанию. В первом случае все подклассы должны будут реализовать эти методы, а во втором — только если реализация шага в подклассе отличается от стандартной версии.
 * <p>4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и после всех шагов.
 * <p>5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p> "+": облегчает повторное использование кода.
 * <p> "-": вы жёстко ограничены скелетом существующего алгоритма.
 * <p> "-": вы можете нарушить принцип подстановки Барбары Лисков, изменяя базовое поведение одного из шагов алгоритма через подкласс.
 * <p> "-": с ростом количества шагов шаблонный метод становится слишком сложно поддерживать.
 *
 * ---------------------------------------------------------------------------------------------------------------------<p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li><strong>Фабричный метод</strong> можно рассматривать как частный случай <strong>Шаблонного метода</strong>. Кроме того, <i>Фабричный метод</i> нередко бывает частью большого класса с <i>Шаблонными методами</i>.</li>
 *
 * <li><strong>Шаблонный метод</strong> использует наследование, чтобы расширять части алгоритма. </strong>
 * <strong>Стратегия</strong> использует делегирование, чтобы изменять выполняемые алгоритмы на лету. <i>Шаблонный метод</i> работает на уровне классов. <i>Стратегия</i> позволяет менять логику отдельных объектов.</li>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Шаблонных методов в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Все не-абстрактные методы классов <strong>java.io.InputStream</strong>, <strong>java.io.OutputStream</strong>, <strong>java.io.Reader</strong> и <strong>java.io.Writer</strong>.
 * <p>Все не-абстрактные методы классов <strong>java.util.AbstractList</strong>, <strong>java.util.AbstractSet</strong> и <strong>java.util.AbstractMap</strong>.
 * <p><strong>javax.servlet.http.HttpServlet</strong>, все методы doXXX() по умолчанию возвращают HTTP-код 405 "Method Not Allowed". Однако вы можете переопределить их при желании.
 */
package patterns.refactoring.guru.behavioral.template;