/**
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><a href="https://refactoring.guru/ru/design-patterns/factory-method"><strong>Фабричный метод</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
 * <ul>Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.</ul>
 * <ul>Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.</ul>
 * <p>* Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
 * <ul>Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?</ul>
 * <ul>Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.</ul>
 * <ul>Например, вы используете готовый UI-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс RoundButton. Но как сказать главному классу фреймворка UIFramework, чтобы он теперь создавал круглые кнопки, вместо стандартных?</ul>
 * <ul>Для этого вы создаёте подкласс UIWithRoundButtons из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля createButton) и вписываете туда создание своего класса кнопок. Затем используете UIWithRoundButtons вместо стандартного UIFramework.</ul>
 *
 * <p>* Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.
 * <ul>Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д.</ul>
 * <ul>Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:
 *      <ul><li>Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.</li>
 *      <li>При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.</li>
 *      <li>А затем вернуть его клиентскому коду.</li>
 *      <li>Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.</li></ul></ul>
 * <ul>Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.</ul>
 * <ul>Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.</ul>
 *
 * <ul>Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Приведите все создаваемые продукты к общему интерфейсу.
 * <p>2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите
 * общий интерфейс продукта.
 * <p>3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки
 * вызовами фабричного метода, перенося в него код создания различных продуктов.
 * <p><ul>В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов
 * нужно создать.</ul>
 * <p><ul>На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный
 * оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.</ul>
 * <p>4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда
 * код создания соответствующего продукта из суперкласса.
 * <p>5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о
 * введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
 * <p><ul>Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта, а также классы продуктов Самолёт,
 * Грузовик и Поезд. Авиа соответствует Самолётам, но для НаземнойПочты есть сразу два продукта. Вы могли бы создать
 * новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в
 * фабричный метод НаземнойПочты
 * аргумент, контролирующий тип создаваемого продукта.</ul>
 * <p>6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём
 * что-то осталось — не беда, это будет его реализацией по умолчанию.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": Избавляет класс от привязки к конкретным классам продуктов.
 * <p>"+": Выделяет код производства продуктов в одно место, упрощая поддержку кода.
 * <p>"+": Упрощает добавление новых продуктов в программу.
 * <p>"+": Реализует принцип открытости/закрытости.
 * <p>"-": Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта
 * надо создать свой подкласс создателя.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>Многие архитектуры начинаются с применения <a href=https://refactoring.guru/ru/design-patterns/factory-method><strong>Фабричного метода <strong></a>(более простого и расширяемого через подклассы)
 * и эволюционируют в сторону <a href=https://refactoring.guru/ru/design-patterns/abstract-factory><strong>Абстрактной фабрики<strong></a>, <a href=https://refactoring.guru/ru/design-patterns/prototype><strong>Прототипа<strong></a> или <a href=https://refactoring.guru/ru/design-patterns/builder><strong>Строителя<strong></a> (более гибких, но и более сложных).</li>
 *
 * <li>Классы <a href=https://refactoring.guru/ru/design-patterns/abstract-factory><strong>Абстрактной фабрики<strong></a> чаще всего реализуются с помощью <a href=https://refactoring.guru/ru/design-patterns/factory-method><strong>Фабричного метода<strong></a>, хотя они могут быть построены
 * и на основе <a href=https://refactoring.guru/ru/design-patterns/prototype><strong>Прототипа<strong></a>.</li>
 *
 * <li><a href=https://refactoring.guru/ru/design-patterns/factory-method><strong>Фабричный<strong></a> метод можно использовать вместе с <a href=https://refactoring.guru/ru/design-patterns/iterator><strong>Итератором<strong></a>, чтобы подклассы коллекций могли создавать подходящие
 * им итераторы.</li>
 *
 * <li><a href=https://refactoring.guru/ru/design-patterns/prototype><strong>Прототип<strong></a> не опирается на наследование, но ему нужна сложная операция инициализации. <a href=https://refactoring.guru/ru/design-patterns/factory-method><strong>Фабричный метод<strong></a>, наоборот,
 * построен на наследовании, но не требует сложной инициализации.</li>
 *
 * <li><a href=https://refactoring.guru/ru/design-patterns/factory-method><strong>Фабричный метод<strong></a> можно рассматривать как частный случай <a href=https://refactoring.guru/ru/design-patterns/template-method><strong>Шаблонного метода<strong></a>. Кроме того, Фабричный метод нередко
 * бывает частью большого класса с Шаблонными методами.</li>
 * </ul>
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Паттерн широко используется в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li>java.util.Calendar#getInstance()</li>
 * <li>java.util.ResourceBundle#getBundle()</li>
 * <li>java.text.NumberFormat#getInstance()</li>
 * <li>java.nio.charset.Charset#forName()</li>
 * <li>java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (Возвращает разные объекты-одиночки, в зависимости от протокола)</li>
 * <li>java.util.EnumSet#of()</li>
 * <li>javax.xml.bind.JAXBContext#createMarshaller() и другие похожие методы</li>
 * </ul>
 */
package patterns.refactoring.guru.creational.factory.method;