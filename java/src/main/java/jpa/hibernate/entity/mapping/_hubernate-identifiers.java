package jpa.hibernate.entity.mapping;

/**
 * <a href="https://www.baeldung.com/hibernate-identifiers">
 *     Hibernate identifiers
 * </a>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>1.Overview</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Identifiers in Hibernate represent the primary key of an entity. This implies the values are unique so that they can identify a specific entity, that they aren't null and that they won't be modified.
 * <p>Hibernate provides a few different ways to define identifiers. In this article, we'll review each method of mapping entity ids using the library.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>2. Simple Identifiers</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>The most straightforward way to define an identifier is by using the {@link javax.persistence.Id @Id} annotation.
 * <p>Simple ids are mapped using @Id to a single property of one of these types: Java primitive and primitive wrapper types, String, Date, BigDecimal and BigInteger.
 * <p>Let's see a quick example of defining an entity with a primary key of type long:
 * <pre>{@code
 * @Entity
 * public class Student {
 *      @Id
 *      private long studentId;
 * }}</pre>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>3. Generated Identifiers</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>If we want to automatically generate the primary key value, we can add the @GeneratedValue annotation.
 * <p>This can use four generation types:
 * {@link javax.persistence.GenerationType#AUTO AUTO},
 * {@link javax.persistence.GenerationType#IDENTITY IDENTITY},
 * {@link javax.persistence.GenerationType#SEQUENCE SEQUENCE} and
 * {@link javax.persistence.GenerationType#TABLE TABLE}.
 * <p>If we don't explicitly specify a value, the generation type defaults to AUTO.
 * <p><strong>3.1. AUTO Generation</strong></p>
 * <p>If we're using the default generation type, the persistence provider will determine values based on the type of the primary key attribute. This type can be numerical or {@link java.util.UUID UUID}.
 * <p>For numeric values, the generation is based on a sequence or table generator, while UUID values will use the
 * {@link org.hibernate.id.UUIDGenerator UUIDGenerator}.
 * <p>Let's first map an entity primary key using AUTO generation strategy:
 * <pre>{@code @Entity
 * public class Student {
 *     @Id
 *     @GeneratedValue
 *     private long studentId;
 * }}</pre>
 * <p>In this case, the primary key values will be unique at the database level.
 * <p>Now we'll look at the UUIDGenerator, which was introduced in Hibernate 5.
 * <p>In order to use this feature, we just need to declare an id of type UUID with @GeneratedValue annotation:
 * <pre>{@code @Entity
 * public class Course {
 *     @Id
 *     @GeneratedValue
 *     private UUID courseId;
 * }}</pre>
 * <p>Hibernate will generate an id of the form “8dd5f315-9788-4d00-87bb-10eed9eff566”.
 * <p><strong>3.2. IDENTITY Generation</strong></p>
 * <p>This type of generation relies on the IdentityGenerator, which expects values generated by an identity column in the database. This means they are auto-incremented.
 * <p>To use this generation type, we only need to set the strategy parameter:
 * <pre>{@code @Entity
 * public class Student {
 *     @Id
 *     @GeneratedValue (strategy = GenerationType.IDENTITY)
 *     private long studentId;
 * }}</pre>
 * <ul><strong>One thing to note is that IDENTITY generation disables batch updates.</strong></ul>
 * <p><strong>3.3. SEQUENCE Generation</strong></p>
 * <p>To use a sequence-based id, Hibernate provides the SequenceStyleGenerator class.
 * <p>This generator uses sequences if our database supports them. It switches to table generation if they aren't supported.
 * <p>In order to customize the sequence name, we can use the @GenericGenerator annotation with SequenceStyleGenerator strategy:
 * <pre>{@code @Entity
 * public class User {
 *     @Id
 *     @GeneratedValue(generator = "sequence-generator")
 *     @GenericGenerator(
 *       name = "sequence-generator",
 *       strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
 *       parameters = {
 *         @Parameter(name = "sequence_name", value = "user_sequence"),
 *         @Parameter(name = "initial_value", value = "4"),
 *         @Parameter(name = "increment_size", value = "1")
 *         }
 *     )
 *     private long userId;
 * }}</pre>
 * <p>In this example, we've also set an initial value for the sequence, which means the primary key generation will start at 4.
 * <p>SEQUENCE is the generation type recommended by the Hibernate documentation.
 * <p>The generated values are unique per sequence. If we don't specify a sequence name, Hibernate will reuse the same hibernate_sequence for different types.
 * <p><strong>3.4. TABLE Generation</strong></p>
 * <p>The TableGenerator uses an underlying database table that holds segments of identifier generation values.
 * <p>Let's customize the table name using the @TableGenerator annotation:
 * <pre>{@code @Entity
 * public class Department {
 *     @Id
 *     @GeneratedValue(strategy = GenerationType.TABLE,
 *       generator = "table-generator")
 *     @TableGenerator(name = "table-generator",
 *       table = "dep_ids",
 *       pkColumnName = "seq_id",
 *       valueColumnName = "seq_value")
 *     private long depId;
 * }
 * }</pre>
 * <p>In this example, we can see that we can also customize other attributes such as the pkColumnName and valueColumnName.
 * <p>However, the disadvantage of this method is that it doesn't scale well and can negatively affect performance.
 * <p>To sum up, these four generation types will result in similar values being generated but use different database mechanisms.
 * <p><strong>3.5. Custom Generator</strong></p>
 * <p>Let's say we don't want to use any of the out-of-the-box strategies. In order to do that, we can define our custom generator by implementing the IdentifierGenerator interface.
 * <p>We'll create a generator that builds identifiers containing a String prefix and a number:
 * <pre>{@code
 * public class MyGenerator
 *   implements IdentifierGenerator, Configurable {
 *
 *     private String prefix;
 *
 *     @Override
 *     public Serializable generate(
 *       SharedSessionContractImplementor session, Object obj)
 *       throws HibernateException {
 *
 *         String query = String.format("select %s from %s",
 *             session.getEntityPersister(obj.getClass().getName(), obj)
 *               .getIdentifierPropertyName(),
 *             obj.getClass().getSimpleName());
 *
 *         Stream ids = session.createQuery(query).stream();
 *
 *         Long max = ids.map(o -> o.replace(prefix + "-", ""))
 *           .mapToLong(Long::parseLong)
 *           .max()
 *           .orElse(0L);
 *
 *         return prefix + "-" + (max + 1);
 *     }
 *
 *     @Override
 *     public void configure(Type type, Properties properties,
 *       ServiceRegistry serviceRegistry) throws MappingException {
 *         prefix = properties.getProperty("prefix");
 *     }
 * }}</pre>
 * <p>In this example, we override the generate() method from the IdentifierGenerator interface.
 * <p>First, we want to find the highest number from the existing primary keys of the form prefix-XX. Then we add 1 to the maximum number found and append the prefix property to get the newly generated id value.
 * <p>Our class also implements the Configurable interface so that we can set the prefix property value in the configure() method.
 * <p>Next, let's add this custom generator to an entity.
 * <p>For this, we can use the @GenericGenerator annotation with a strategy parameter that contains the full class name of our generator class:
 * <pre>{@code
 * @Entity
 * public class Product {
 *     @Id
 *     @GeneratedValue(generator = "prod-generator")
 *     @GenericGenerator(name = "prod-generator",
 *       parameters = @Parameter(name = "prefix", value = "prod"),
 *       strategy = "com.baeldung.hibernate.pojo.generator.MyGenerator")
 *     private String prodId;
 * }}</pre>
 * <p>Also, notice we've set the prefix parameter to “prod”.
 * <p>Let's see a quick JUnit test for a clearer understanding of the id values generated:
 *<pre>{@code
 * @Test
 * public void whenSaveCustomGeneratedId_thenOk() {
 *     Product product = new Product();
 *     session.save(product);
 *     Product product2 = new Product();
 *     session.save(product2);
 *     assertThat(product2.getProdId()).isEqualTo("prod-2");
 * }}</pre>
 * <p>Here the first value generated using the “prod” prefix was “prod-1”, followed by “prod-2”.
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>4. Composite Identifiers</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Besides the simple identifiers we've seen so far, Hibernate also allows us to define composite identifiers.
 * <p>A composite id is represented by a primary key class with one or more persistent attributes.
 * The primary key class must fulfill several conditions:
 * <ul>
 * <li>It should be defined using {@link javax.persistence.EmbeddedId @EmbeddedId} or{@link javax.persistence.IdClass @IdClass} annotations.</li>
 * <li>It should be public, serializable and have a public no-arg constructor.</li>
 * <li>Finally, it should implement {@link Object#equals(Object)} and {@link Object#hashCode()} methods.</li>
 * </ul>
 * <p>The class's attributes can be basic, composite or ManyToOne, while avoiding collections and OneToOne attributes.
 * <p><strong>{@link javax.persistence.EmbeddedId 4.1 @EmbeddedId}</strong></p>
 * <p>Now let's look at how to define an id using @EmbeddedId.
 * <p>First, we need a primary key class annotated with @Embeddable:
 * <pre>{@code
 * @Embeddable
 * public class OrderEntryPK implements Serializable {
 *     private long orderId;
 *     private long productId;
 * }}</pre>
 * <p>Next, we can add an id of type OrderEntryPK to an entity using @EmbeddedId:
 * <pre>{@code @Entity public class OrderEntry {
 *       @EmbeddedId
 *       private OrderEntryPK entryId;
 *   }}</pre>
 * Let's see how we can use this type of composite id to set the primary key for an entity:
 * <pre>{@code
 * @Test
 * public void whenSaveCompositeIdEntity_thenOk() {
 *     OrderEntryPK entryPK = new OrderEntryPK();
 *     entryPK.setOrderId(1L);
 *     entryPK.setProductId(30L);
 *
 *     OrderEntry entry = new OrderEntry();
 *     entry.setEntryId(entryPK);
 *     session.save(entry);
 *
 *     assertThat(entry.getEntryId().getOrderId()).isEqualTo(1L);
 * }}</pre>
 * <p>Here the OrderEntry object has an OrderEntryPK primary id formed of two attributes: orderId and productId.
 * <p><strong>4.2. @IdClass</strong></p>
 * <p>The @IdClass annotation is similar to the @EmbeddedId. The difference with @IdClass is that the attributes are defined in the main entity class using @Id for each one. The primary key class will look the same as before.
 * <p>Let's rewrite the OrderEntry example with an @IdClass:
 * <pre>{@code @Entity
 * @IdClass(OrderEntryPK.class)
 * public class OrderEntry {
 *     @Id
 *     private long orderId;
 *     @Id
 *     private long productId;
 * }}</pre>
 * <p>Then we can set the id values directly on the OrderEntry object:
 * <pre>{@code
 * @Test
 * public void whenSaveIdClassEntity_thenOk() {
 *     OrderEntry entry = new OrderEntry();
 *     entry.setOrderId(1L);
 *     entry.setProductId(30L);
 *     session.save(entry);
 *     assertThat(entry.getOrderId()).isEqualTo(1L);
 * }}</pre>
 * <p>Note that for both types of composite ids, the primary key class can also contain @ManyToOne attributes.
 * <p>Hibernate also allows defining primary keys made up of @ManyToOne associations combined with @Id annotation. In this case, the entity class should also fulfill the conditions of a primary key class.
 * <p>However, the disadvantage of this method is that there's no separation between the entity object and the identifier.</p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>5. Derived Identifiers</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>Derived identifiers are obtained from an entity's association using the @MapsId annotation.
 * <p>First, let's create a UserProfile entity that derives its id from a one-to-one association with the User entity:
 * <pre>{@code @Entity
 * public class UserProfile {
 *     @Id
 *     private long profileId;
 *
 *     @OneToOne
 *     @MapsId
 *     private User user;
 * }}</pre>
 * <p>Next, let's verify that a UserProfile instance has the same id as its associated User instance:
 * <pre>{@code
 * @Test
 * public void whenSaveDerivedIdEntity_thenOk() {
 *     User user = new User();
 *     session.save(user);
 *
 *     UserProfile profile = new UserProfile();
 *     profile.setUser(user);
 *     session.save(profile);
 *
 *     assertThat(profile.getProfileId()).isEqualTo(user.getUserId());
 * }}</pre>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>6. Conclusion</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>In this article, we've seen the multiple ways we can define identifiers in Hibernate.
 * <p>The full source code of the examples can be found over on GitHub.
 */
class HibernateIdentifiers {}