/**
 * ---------------------------------------------------------------------------------------------------------------------
 *  <p><a href=https://refactoring.guru/ru/design-patterns/flyweight><strong>Легковес</strong></a></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую
 * оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения
 * одинаковых данных в каждом объекте.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Неизменяемость Легковесов</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние
 * невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора.
 * Он не должен иметь сеттеров и публичных полей.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Фабрика Легковесов</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>Для удобства работы с легковесами и контекстами можно создать фабричный метод, принимающий в параметрах
 * всё внутреннее (а иногда и внешнее) состояние желаемого объекта.</ul>
 *
 * <ul>Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием,
 * что и требуемое. Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый.
 * Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику.
 * Его даже можно сделать статическим и поместить в класс легковесов.</ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Применимость</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>* Когда не хватает оперативной памяти для поддержки всех нужных объектов.
 * <ul>Эффективность паттерна Легковес во многом зависит от того, как и где он используется. Применяйте этот паттерн,
 * когда выполнены все перечисленные условия:
 *     <ul>
 *          <li>в приложении используется большое число объектов;</li>
 *          <li>из-за этого высоки расходы оперативной памяти</li>
 *          <li>большую часть состояния объектов можно вынести за пределы их классов;</li>
 *          <li>большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку
 *              внешнее состояние вынесено.</li>
 *     </ul>
 * </ul>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Шаги реализации</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>1. Разделите поля класса, который станет легковесом, на две части:
 * <ul>
 * <li>внутреннее состояние: значения этих полей одинаковы для большого числа объектов;</li>
 * <li>внешнее состояние (контекст): значения полей уникальны для каждого объекта.</li></ul>
 * <p>2. Оставьте поля внутреннего состояния в классе, но убедитесь, что их значения неизменяемы. Эти поля должны
 * инициализироваться только через конструктор.
 * <p>3. Превратите поля внешнего состояния в параметры методов, где эти поля использовались. Затем удалите поля из класса.
 * <p>4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен
 * запрашивать из этой фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
 * <p>5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы
 * объекта легковеса.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Преимущества и недостатки</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <p>"+": экономит оперативную память.
 * <p>"+": расходует процессорное время на поиск/вычисление контекста.
 * <p>"-": усложняет код программы из-за введения множества дополнительных классов.
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Отношения с другими паттернами</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 * <ul>
 * <li><a href=https://refactoring.guru/ru/design-patterns/composite><strong>Компоновщик</strong></a> часто совмещают с <a href=https://refactoring.guru/ru/design-patterns/flyweight><strong>Легковесом</strong></a>, чтобы реализовать общие ветки дерева и сэкономить при этом память.</li>
 * <li><a href=https://refactoring.guru/ru/design-patterns/flyweight><strong>Легковес</strong></a> показывает, как создавать много мелких объектов, а <a href=https://refactoring.guru/ru/design-patterns/facade><strong>Фасад</strong></a> показывает, как создать один объект,
 * который отображает целую подсистему.</li>
 * <li>Паттерн <a href=https://refactoring.guru/ru/design-patterns/flyweight><strong>Легковес</strong></a> может напоминать <a href=https://refactoring.guru/ru/design-patterns/singleton><strong>Одиночку</strong></a>, если для конкретной задачи у вас получилось свести количество
 * объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:</li>
 * <p>1. В отличие от Одиночки, вы можете иметь множество объектов-легковесов.</p>
 * <p>2. Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
 * </p></ul>
 *
 * ---------------------------------------------------------------------------------------------------------------------
 * <p><strong>Примеры Легковеса в стандартных библиотеках Java:</strong></p>
 * ---------------------------------------------------------------------------------------------------------------------
 *
 * <strong>java.lang.Integer#valueOf(int)</strong> (а также Boolean, Byte, Character, Short, Long и BigDecimal)
 */
package architecture.patterns.basic.refactoring.guru.structural.flyweight;